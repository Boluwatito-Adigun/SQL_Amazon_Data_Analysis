/*
1. Top Selling Products
Query the top 10 products by total sales value.
Challenge: Include product name, total quantity sold, and total sales value.
*/

SELECT 
    pr.product_name,
    sum(oi.quantity) AS total_quantity,
    oi.price_per_unit,
    oi.price_per_unit * sum(oi.quantity) AS total_sales
FROM
    products pr
JOIN order_items oi 
    on pr.product_id = oi.product_id
GROUP BY
    pr.product_name,
    oi.price_per_unit
ORDER BY
    total_sales DESC
LIMIT 10;


/*
2. Revenue by Category
Calculate total revenue generated by each product category.
Challenge: Include the percentage contribution of each category to total revenue.
*/

ALTER TABLE order_items
ADD COLUMN total_sales FLOAT;

SELECT * FROM order_items

UPDATE order_items
SET total_sales = quantity * price_per_unit;


SELECT
    pr.category_id,
    c.category_name,
    SUM(oi.total_sales) AS total_revenue,
    SUM(oi.total_sales)/ 
                        (SELECT SUM(total_sales) FROM order_items) * 100 AS percentage_contribution
FROM 
    order_items oi
JOIN products pr
    ON pr.product_id = oi.product_id
LEFT JOIN category c
    ON c.category_id = pr.category_id
GROUP BY
    c.category_name,
    pr.category_id
ORDER BY
    total_revenue DESC;

/*
3. Average Order Value (AOV)
Compute the average order value for each customer.
Challenge: Include only customers with more than 5 orders.
*/

SELECT 
    concat (c.first_name, ' ', c.last_name) AS full_name,
    o.customer_id,
    count(o.order_id) AS number_of_orders,
    AVG(total_sales)
FROM order_items oi
JOIN orders o
    ON oi.order_id = o.order_id
JOIN customers c
     ON c.customer_id = o.customer_id
GROUP BY
    o.customer_id,
    full_name
HAVING count(o.order_id) > 5
ORDER BY
    number_of_orders DESC

/*
4. Monthly Sales Trend
Query monthly total sales over the past one year.
Challenge: Display the sales trend, grouping by month, return current_month sale, last month sale!
*/

SELECT 
    year,
    month,
    total_sales AS current_month_sale,
    LAG(total_sales, 1) OVER(ORDER BY year, month) AS previous_month_sale
FROM
(
    SELECT 
        EXTRACT(MONTH FROM o.order_date) AS month,
        EXTRACT(YEAR FROM o.order_date) AS year,
        ROUND(SUM(oi.total_sales)::numeric, 2) AS total_sales
    FROM
        order_items oi
    JOIN orders o  
        ON oi.order_id = o.order_id
    WHERE o.order_date BETWEEN '2023-07-30' AND '2024-07-30' 
    GROUP BY
        month,
        year
    ORDER BY
        year, month
) AS sub_q1


/*
5. Customers with No Purchases
Find customers who have registered but never placed an order.
Challenge: List customer details and the time since their registration.
*/

SELECT 
     concat (c.first_name, ' ', c.last_name) AS full_name,
     c.state,
     c.address
     
FROM    
    customers c
LEFT JOIN orders o
    ON c.customer_id = o.customer_id
WHERE o.customer_id IS NULL
GROUP BY    
    full_name,
    c.state,
    c.address
ORDER BY 
    full_name


/*
6. Least-Selling Categories by State
Identify the least-selling product category for each state.
Challenge: Include the total sales for that category within each state.
*/


WITH temp_table_1 AS
(
    SELECT  
        cu.state AS states,
        ca.category_name AS category_name,
        ROUND(sum(oi.total_sales)::numeric, 2) AS total_sales,
        RANK() OVER(PARTITION BY cu.state ORDER BY ROUND(sum(oi.total_sales)::numeric, 2)) AS rank
    FROM category ca 
        JOIN products pr
            ON ca.category_id = pr.category_id
        JOIN order_items oi
            ON oi.product_id = pr.product_id
        JOIN orders o
            ON oi.order_id = o.order_id
        JOIN customers cu
            ON o.customer_id = cu.customer_id
    GROUP BY
        cu.state,
        ca.category_name
    ORDER BY
        cu.state,
        total_sales
)

SELECT
    states,
    category_name,
    total_sales
FROM
    temp_table_1
WHERE rank = 1;


/*
7. Customer Lifetime Value (CLTV)
Calculate the total value of orders placed by each customer over their lifetime.
Challenge: Rank customers based on their CLTV.
*/


SELECT 
     concat (c.first_name, ' ', c.last_name) AS full_name,
     COUNT(o.order_id) AS number_of_orders,
     ROUND (SUM(oi.total_sales)::numeric, 2) AS order_value,
     DENSE_RANK () OVER(ORDER BY SUM(oi.total_sales) DESC) AS rank
     
FROM customers c
LEFT JOIN orders o 
    ON c.customer_id = o.customer_id
    JOIN order_items oi
    ON o.order_id = oi.order_id
GROUP BY
    full_name
ORDER BY 
    order_value DESC;

/*
8. Inventory Stock Alerts
Query products with stock levels less than 10 units
Challenge: Include last restock date and warehouse information.
*/

SELECT
    pr.product_name,
    i.stock,
    i.last_stock_date
FROM products pr
JOIN inventory i 
    ON pr.product_id = i.product_id
WHERE i.stock < 10
ORDER BY
    i.stock


/*
9. Shipping Delays
Identify orders where the shipping date is later than 3 days after the order date.
Challenge: Include customer, order details, and delivery provider.
*/


SELECT 
    concat (c.first_name, ' ', c.last_name) AS full_name,
    s.shipping_providers,
    s.delivery_status,
    shipping_date - order_date AS time_gap

FROM customers c
JOIN orders o
    ON c.customer_id = o.customer_id
JOIN shipping s
    ON o.order_id = s.order_id
WHERE shipping_date - order_date > 3


/*
10. Payment Success Rate 
Calculate the percentage of successful payments across all orders.
Challenge: Include breakdowns by payment status (e.g., failed, pending).
*/

SELECT 
    payment_status,
    count(payment_status) AS total_count,
    ROUND(count(payment_status) / (SELECT count(payment_status) FROM payments)::numeric, 2)* 100 AS percentage
FROM  payments
GROUP BY
    payment_status
ORDER BY
    total_count DESC;

/*
11. Top Performing Sellers
Find the top 5 sellers based on total sales value.
Challenge: Include both successful and failed orders, and display their percentage of successful orders.
*/

WITH top_sellers 
AS 
(
    SELECT 
        o.seller_id,
        s.seller_name,
        ROUND(sum(total_sales)::numeric, 2) AS total_sales
    FROM sellers s  
        JOIN orders o
            ON s.seller_id = o.seller_id
        JOIN order_items oi
            ON o.order_id = oi.order_id
    GROUP BY
        o.seller_id,
        s.seller_name
    ORDER BY
        total_sales DESC
    LIMIT 5
),

sellers_report
AS
( 
    SELECT 
        o.seller_id AS seller_id,
        ts.seller_name AS seller_name,
        o.order_status,
        Count(o.order_status) AS total_orders
     FROM 
        orders o
    JOIN top_sellers ts
        ON o.seller_id = ts.seller_id
    WHERE o.order_status NOT IN ('Inprogress', 'Returned')
    GROUP BY
        o.order_status,
        o.seller_id,
        ts.seller_name
)

SELECT 
    seller_id,
    seller_name,
    SUM(CASE WHEN order_status = 'Completed' THEN total_orders ELSE 0 END) AS completed_orders,
    SUM(CASE WHEN order_status = 'Cancelled' THEN total_orders ELSE 0 END) AS cancelled_orders,
    SUM(total_orders) AS total_orders,
    ROUND(SUM(CASE WHEN order_status = 'Completed' THEN total_orders ELSE 0 END)::numeric /
    SUM(total_orders)::numeric * 100, 2) AS percentage_successful_orders

FROM  sellers_report
GROUP BY
    seller_id,
    seller_name

/*
12. Product Profit Margin
Calculate the profit margin for each product (difference between price and cost of goods sold).
Challenge: Rank products by their profit margin, showing highest to lowest.
*/ 

SELECT
    oi.product_id,
    pr.product_name,
    ROUND(SUM(pr.price - pr.cogs * oi.quantity)::numeric, 2) AS total_profit,
    ROUND(SUM(pr.price - pr.cogs * oi.quantity)::numeric / Sum(oi.total_sales)::numeric * 100, 2) AS profit_margin,
    DENSE_RANK() 
    OVER(ORDER BY SUM(pr.price - pr.cogs * oi.quantity)::numeric / SUM(oi.total_sales)::numeric * 100 DESC) AS rank
FROM products pr
    JOIN order_items oi
        ON pr.product_id = oi.product_id
GROUP BY    
     oi.product_id,
     pr.product_name
ORDER BY
    profit_margin DESC


/*
13. Most Returned Products
Query the top 10 products by the number of returns.
Challenge: Display the return rate as a percentage of total units sold for each product.
*/

SELECT
    pr.product_id,
    pr.product_name,
    COUNT(*) AS total_unit_sold,
    SUM(CASE WHEN o.order_status = 'Returned' THEN 1 ELSE 0 END) AS total_returned,
    ROUND (SUM(CASE WHEN o.order_status = 'Returned' THEN 1 ELSE 0 END)::numeric / COUNT(*)::numeric * 100, 2) AS return_percentage
FROM order_items oi
    JOIN products pr
        ON oi.product_id = pr.product_id
    JOIN orders o
       ON o.order_id = oi.order_id
GROUP BY
    pr.product_id,
    pr.product_name
ORDER BY
    total_returned DESC
LIMIT 10


/*
14. Orders Pending Shipment
Find orders that have been paid but are still pending shipment.
Challenge: Include order details, payment date, and customer information.
*/

SELECT
    c.customer_id,
    concat (c.first_name, ' ', c.last_name) AS full_name,
    c.state,
    p.payment_date,
    s.delivery_status

FROM orders o
    JOIN customers c
        ON o.customer_id = c.customer_id
    JOIN payments p
        ON o.order_id = p.order_id
    JOIN shipping s
        ON o.order_id = s.order_id
WHERE 
    p.payment_status = 'Payment Successed' AND
    s.delivery_status = 'Shipped'


/*
15. Inactive Sellers
Identify sellers who havenâ€™t made any sales in the last 6 months.
Challenge: Show the last sale date and total sales from those sellers.
*/


WITH sellers_with_no_sales
AS
(
SELECT 
  *
FROM
    sellers
WHERE seller_id NOT IN (SELECT seller_id FROM orders 
                            WHERE order_date BETWEEN '2023-07-30' AND '2024-01-30')
)

SELECT
    ss.seller_id,
    ss.seller_name,
    MAX(o.order_date) AS last_sale_date,
    ROUND(SUM(oi.total_sales)::NUMERIC, 2) AS total_sale

FROM orders o
    JOIN order_items oi
        ON o.order_id = oi.order_id
    JOIN sellers_with_no_sales ss 
        ON o.seller_id = ss.seller_id
GROUP BY 
    ss.seller_id,
    ss.seller_name

/*
16. Identify customers into returning or new
if the customer has done more than 5 orders categorize them as returning otherwise new
Challenge: List customers id, name, total orders, total returns
*/

SELECT 
    c.customer_id,
    concat (c.first_name, ' ', c.last_name) AS full_name,
    COUNT(c.customer_id) AS number_of_orders,
    CASE 
        WHEN COUNT(c.customer_id) > 5 THEN 'Returning'
        WHEN COUNT(c.customer_id) <= 5 THEN 'New'
    END AS category
FROM customers c
    JOIN orders o
    ON c.customer_id = o. customer_id
GROUP BY
    c.customer_id,
    full_name
ORDER BY
    c.customer_id
/*
17. Cross-Sell Opportunities
Find customers who purchased product A but not product B (e.g., customers who bought AirPods but not AirPods Max).
Challenge: Suggest cross-sell opportunities by displaying matching product categories.
*/

SELECT 
    concat (c.first_name, ' ', c.last_name) AS full_name,
    pr.product_name,
    RANK() OVER(PARTITION BY concat (c.first_name, ' ', c.last_name) ORDER BY pr.product_name )
FROM products pr
    JOIN order_items oi
        ON pr.product_id = oi.product_id
    JOIN orders o
        ON oi.order_id = o.order_id
    JOIN customers c 
        ON o.customer_id = c.customer_id



/*
18. Top 5 Customers by Orders in Each State
Identify the top 5 customers with the highest number of orders for each state.
Challenge: Include the number of orders and total sales for each customer.
*/

WITH top_5_customer_by_state 
AS
(
    SELECT
        c.state,
        concat (c.first_name, ' ', c.last_name) AS full_name,
        count(o.order_id) AS number_of_orders,
        ROUND (SUM(total_sales)::numeric, 2) AS total_sales,
        DENSE_RANK() OVER(PARTITION BY c.state ORDER BY count(o.order_id) DESC, c.state ) AS rank
    FROM customers c
    JOIN orders o
        ON c.customer_id = o.customer_id
    JOIN order_items oi
        ON oi.order_id = o.order_id
    GROUP BY
        full_name,
        c.state
    ORDER BY 
        c.state,
        number_of_orders DESC
)

SELECT *

FROM top_5_customer_by_state
WHERE rank <=5

/*
19. Revenue by Shipping Provider
Calculate the total revenue handled by each shipping provider.
Challenge: Include the total number of orders handled and the average delivery time for each provider.
*/
 
SELECT 
    s.shipping_providers,
    COUNT(oi.order_id) AS number_of_orders,
    ROUND(SUM(oi.total_sales)::numeric, 2) AS total_revenue,
    COALESCE (AVG((return_date - shipping_date)::numeric), 0)AS avg_delivery_time
FROM order_items oi 
JOIN shipping s 
    ON oi.order_id = s.order_id
JOIN orders o
    ON o.order_id = oi.order_id
GROUP BY  
    s.shipping_providers
ORDER BY
    total_revenue DESC

